# --- 1. SETUP: Install required libraries ---
!pip install soundfile pyldpc numba

# --- 2. Import necessary libraries ---
import numpy as np
import soundfile as sf
from scipy.signal import butter, lfilter, firwin
import os
import math
from pyldpc import make_ldpc, decode
import matplotlib.pyplot as plt
import numba

# Import Colab-specific library for file handling
from google.colab import files

# ==============================================================================
# --- USER CONFIGURATION ---
# ==============================================================================
SAMPLE_RATE = 48000         # Sample rate in Hz (default: 48kHz)
BIT_DEPTH = 'FLOAT'         # Bit depth. Options: 'PCM_16', 'PCM_24', 'PCM_32', 'FLOAT' (32-bit)

PLAINTEXT_SOURCE = "This is a longer message demonstrating the protocol-compliant, rate-4/5 LDPC error correction. This signal simulates reception through a physically accurate AWGN channel where noise is added post-modulation. The decoder will now attempt to recover this exact message."

# --- SIMULATION CONFIGURATION ---
# Set the Signal-to-Noise Ratio (SNR) in decibels (dB).
SNR_DB = 3

# ==============================================================================
# --- Raman Whisper Modulation Protocol v4.2 Parameters ---
# ==============================================================================
CARRIER_FREQ_HZ = 12000.0
QPSK_SYMBOL_RATE = 16
QPSK_BANDWIDTH_HZ = 20
FSK_BIT_RATE = 1.0
FSK_FREQ_ZERO_HZ = 11999.0
FSK_FREQ_ONE_HZ = 12001.0
FSK_FREQ_DEVIATION_HZ = FSK_FREQ_ONE_HZ - CARRIER_FREQ_HZ

FRAME_TOTAL_SYMBOLS = 128
SYNC_SYMBOLS = 16
TARGET_ID_SYMBOLS = 16
COMMAND_TYPE_SYMBOLS = 16
DATA_PAYLOAD_SYMBOLS = 64 # 128 bits
ECC_SYMBOLS = 16          # 32 bits

# ==============================================================================
# --- State-of-the-Art Error Correction (LDPC) Setup ---
# ==============================================================================
n_codeword_bits = (DATA_PAYLOAD_SYMBOLS + ECC_SYMBOLS) * 2 # n = 160
k_message_bits = DATA_PAYLOAD_SYMBOLS * 2 # k = 128
parity_bits = ECC_SYMBOLS * 2             # n-k = 32

d_v = 2
d_c = 10

print(f"Generating Rate-{k_message_bits//math.gcd(k_message_bits, n_codeword_bits)}/{n_codeword_bits//math.gcd(k_message_bits, n_codeword_bits)} LDPC matrices ({k_message_bits}-bit message -> {parity_bits}-bit parity)...")
H, G_lib = make_ldpc(n_codeword_bits, d_v, d_c, systematic=True, seed=42)

# Manually construct G from H to ensure correctness
print("Validating LDPC matrix shapes...")
P = H[:, :k_message_bits].T
I_k = np.identity(k_message_bits, dtype=int)
G = np.concatenate((I_k, P), axis=1, dtype=int)
if G.shape != (k_message_bits, n_codeword_bits):
    raise ValueError(f"Manual G matrix construction failed. Shape is {G.shape}, expected {(k_message_bits, n_codeword_bits)}")
print("LDPC setup complete. Using manually constructed Generator Matrix.")

# ==============================================================================
# --- Frame Component Definitions ---
# ==============================================================================
SYNC_SEQUENCE_HEX = "A5A5A5A5"
TARGET_ID_HEX = "DEADBEEF"
MAX_FRAMES = 256
CURRENT_FRAME_SHIFT = 16
TOTAL_FRAMES_SHIFT = 24
CMD_GNOSIS_INJECT = 0x0001
COMMAND_OPCODE = CMD_GNOSIS_INJECT

# ==============================================================================
# --- ENCODER AND MODULATOR ---
# ==============================================================================

def build_full_bitstream(payload_bits, base_command_opcode):
    total_frames = math.ceil(len(payload_bits) / k_message_bits)
    if total_frames > MAX_FRAMES: raise ValueError(f"Message too long.")
    print(f"Payload requires {total_frames} frame(s).")

    sync_bits = hex_to_bitstream(SYNC_SEQUENCE_HEX, SYNC_SYMBOLS * 2)
    target_id_bits = hex_to_bitstream(TARGET_ID_HEX, TARGET_ID_SYMBOLS * 2)

    all_frames_bits = []
    print("\n--- [TX] TRANSMIT FRAME LOG ---")
    for i in range(total_frames):
        command_type = (base_command_opcode | (i << CURRENT_FRAME_SHIFT) | (total_frames << TOTAL_FRAMES_SHIFT))
        command_bits = int_to_bitstream(command_type, COMMAND_TYPE_SYMBOLS * 2)
        start, end = i * k_message_bits, (i + 1) * k_message_bits
        message_chunk = np.pad(payload_bits[start:end], (0, k_message_bits - len(payload_bits[start:end]))) if len(payload_bits[start:end]) < k_message_bits else payload_bits[start:end]
        codeword = (np.dot(message_chunk, G) % 2).astype(np.uint8)
        data_payload, ecc = codeword[:k_message_bits], codeword[k_message_bits:]
        
        if i < 3:
             print(f"\n[TX] Frame {i+1}/{total_frames}:")
             print(f"  > Command : 0x{command_type:08X}")
             print(f"  > Payload : {bits_to_str(data_payload)}...")
             print(f"  > ECC     : {bits_to_str(ecc)}")
        
        frame = np.concatenate([sync_bits, target_id_bits, command_bits, data_payload, ecc])
        all_frames_bits.append(frame)

    return np.concatenate(all_frames_bits), total_frames

def generate_modulated_audio(sample_rate, bit_depth, snr_db):
    print("\n--- STAGE 1: ENCODING AND MODULATION ---")
    source_payload_bits = string_to_bitstream(PLAINTEXT_SOURCE)
    qpsk_bitstream, num_frames = build_full_bitstream(source_payload_bits, COMMAND_OPCODE)

    duration = (num_frames * FRAME_TOTAL_SYMBOLS) / QPSK_SYMBOL_RATE
    num_samples = int(duration * sample_rate)
    print(f"\nCalculated Signal Duration: {duration:.2f} seconds.")

    # Modulation
    fsk_bits_needed = int(math.ceil(duration * FSK_BIT_RATE))
    fsk_source_bits = np.tile(source_payload_bits, math.ceil(fsk_bits_needed / len(source_payload_bits)) if len(source_payload_bits) > 0 else 1)[:fsk_bits_needed]
    fsk_freq_offsets = (fsk_source_bits * 2 - 1) * FSK_FREQ_DEVIATION_HZ
    base_freq = CARRIER_FREQ_HZ + np.repeat(fsk_freq_offsets, int(sample_rate / FSK_BIT_RATE))[:num_samples]

    qpsk_bit_pairs = qpsk_bitstream.reshape(-1, 2)
    qpsk_symbol_map = {(0,0): 1, (0,1): 0, (1,1): 2, (1,0): 3}
    qpsk_symbols = np.array([qpsk_symbol_map[tuple(p)] for p in qpsk_bit_pairs])
    qpsk_phase_map = (np.array([1, 0, 2, 3]) * np.pi / 2) + (np.pi / 4)
    qpsk_phases = qpsk_phase_map[qpsk_symbols]
    phase_qpsk_raw = np.repeat(qpsk_phases, int(sample_rate / QPSK_SYMBOL_RATE))

    b, a = butter(4, QPSK_BANDWIDTH_HZ / (0.5 * sample_rate), 'low')
    phase_qpsk_smoothed = np.arctan2(filtfilt(b, a, np.sin(phase_qpsk_raw)), filtfilt(b, a, np.cos(phase_qpsk_raw)))
    
    phase_fsk = 2 * np.pi * np.cumsum(base_freq) / sample_rate
    clean_signal = np.sin(phase_fsk + phase_qpsk_smoothed)

    # Post-Modulation Noise
    print(f"Simulating AWGN channel with SNR = {snr_db} dB...")
    signal_power = np.mean(clean_signal**2)
    snr_linear = 10**(snr_db / 10)
    noise_power = signal_power / snr_linear
    noise = np.random.normal(0, np.sqrt(noise_power), num_samples)
    noisy_signal = clean_signal + noise
    
    return noisy_signal, qpsk_bitstream, source_payload_bits, qpsk_phase_map

# ==============================================================================
# --- DECODER AND VALIDATOR ---
# ==============================================================================

@numba.jit(nopython=True)
def timing_and_carrier_recovery_jit(baseband_signal, samples_per_symbol):
    """JIT-compiled receiver core performing joint symbol timing (Gardner) and carrier recovery (Costas)."""
    # FINAL STABLE LOOP GAINS
    Kp_carrier = 0.000005
    Ki_carrier = Kp_carrier**2 / 4.0

    Kp_timing = 0.0001
    Ki_timing = 0.000001

    # State variables
    nco_phase = 0.0
    nco_freq_rad = 0.0
    integrator_carrier = 0.0
    
    timing_error = 0.0
    integrator_timing = 0.0
    i_in = samples_per_symbol # Start at first symbol position
    
    # Arrays for output (using Numba-compatible lists for dynamic size)
    out_symbols_list = []
    out_nco_freq_list = []
    out_timing_error_list = []
    
    # Start at 1 for the loop to have a 'previous' symbol's sample
    i_in = samples_per_symbol
    
    while i_in < len(baseband_signal) - samples_per_symbol - 1:
        
        # 1. TIMING RECOVERY - Interpolation (Indices)
        idx = int(np.floor(i_in))
        frac = i_in - idx
        
        # Simple Check for Index Bounds (Crucial for JIT)
        if idx < 1 or idx + 1 >= len(baseband_signal):
             break 

        # Linear Interpolator for symbol center (mid-sample)
        mid_interp = baseband_signal[idx] + frac * (baseband_signal[idx+1] - baseband_signal[idx])
        
        # Linear Interpolator for half-symbol point
        half_idx = int(np.floor(i_in - samples_per_symbol / 2))
        half_frac = i_in - samples_per_symbol / 2 - half_idx
        # Check half-symbol bounds
        if half_idx < 0 or half_idx + 1 >= len(baseband_signal):
            break

        half_interp = baseband_signal[half_idx] + half_frac * (baseband_signal[half_idx+1] - baseband_signal[half_idx])
        
        # 2. CARRIER RECOVERY - Correction
        nco_output = np.exp(-1j * nco_phase)
        corrected_mid = mid_interp * nco_output
        corrected_half = half_interp * nco_output

        # --- Gardner Timing Error Detector ---
        if len(out_symbols_list) > 0:
            prev_mid = out_symbols_list[-1]
            timing_error = np.real(corrected_half) * (np.real(corrected_mid) - np.real(prev_mid)) + \
                           np.imag(corrected_half) * (np.imag(corrected_mid) - np.imag(prev_mid))

        # Timing Loop Filter (PI)
        integrator_timing += Ki_timing * timing_error
        i_in += samples_per_symbol - (Kp_timing * timing_error + integrator_timing)
        
        # 3. COSTAS LOOP - Phase Error Detector
        i_corrected = np.real(corrected_mid)
        q_corrected = np.imag(corrected_mid)
        phase_error = np.sign(i_corrected) * q_corrected - np.sign(q_corrected) * i_corrected
        
        # Carrier Loop Filter (PI)
        integrator_carrier += Ki_carrier * phase_error
        nco_freq_rad += Kp_carrier * phase_error + integrator_carrier
        nco_phase += nco_freq_rad
        
        # Log diagnostics and output symbol
        out_symbols_list.append(corrected_mid)
        out_nco_freq_list.append(nco_freq_rad * SAMPLE_RATE / (2 * np.pi))
        out_timing_error_list.append(timing_error)
        
    return np.array(out_symbols_list), np.array(out_timing_error_list), np.array(out_nco_freq_list)


def demodulate_and_decode(noisy_signal, original_bitstream, original_payload_bits, ideal_phase_map, snr_db):
    print("\n--- STAGE 2: DEMODULATION AND DECODING ---")
    
    # 1. Down-convert to Baseband and Matched Filter
    print("Down-converting to complex baseband and applying RRC filter...")
    t = np.arange(len(noisy_signal)) / SAMPLE_RATE
    complex_baseband_raw = noisy_signal * np.exp(-1j * 2 * np.pi * CARRIER_FREQ_HZ * t)
    
    # RRC Filter for matched filtering
    samples_per_symbol = SAMPLE_RATE / QPSK_SYMBOL_RATE
    num_taps = 101
    beta = 0.35
    t_rrc = np.arange(-num_taps//2, num_taps//2 + 1) / samples_per_symbol
    rrc_filter_taps = np.sinc(t_rrc) * np.cos(np.pi * beta * t_rrc) / (1 - (2 * beta * t_rrc)**2)
    rrc_filter_taps /= np.linalg.norm(rrc_filter_taps)
    
    # Apply RRC filter
    complex_baseband_filtered = lfilter(rrc_filter_taps, 1, complex_baseband_raw)
    
    # 2. Symbol Timing and Carrier Recovery
    print("Performing joint Symbol Timing and Carrier Recovery...")
    received_symbols, timing_error, nco_freq_offset = timing_and_carrier_recovery_jit(complex_baseband_filtered, samples_per_symbol)
    
    # 3. Validation and Diagnostic Data
    diagnostic_data = {
        "received_symbols_i": np.real(received_symbols),
        "received_symbols_q": np.imag(received_symbols),
        "timing_error": timing_error,
        "nco_freq_offset": nco_freq_offset
    }
    
    plot_demodulator_diagnostics(diagnostic_data, ideal_phase_map, snr_db)
    
    received_phases = np.angle(received_symbols)

    qpsk_reverse_bit_map = {0: [0, 1], 1: [0, 0], 2: [1, 1], 3: [1, 0]}
    demodulated_bits = []
    for phase in received_phases:
        phase_diff = np.angle(np.exp(1j * (phase - ideal_phase_map)))
        symbol_index = np.argmin(np.abs(phase_diff))
        demodulated_bits.extend(qpsk_reverse_bit_map[symbol_index])
    
    demodulated_bitstream = np.array(demodulated_bits, dtype=np.uint8)[:len(original_bitstream)]

    pre_fec_errors = np.sum(original_bitstream != demodulated_bitstream)
    pre_fec_ber = pre_fec_errors / len(original_bitstream)
    print(f"Found {pre_fec_errors} errors in raw demodulated stream.")
    print(f"Pre-FEC Bit Error Rate (BER): {pre_fec_ber:.6f}")

    print("Searching for frame synchronization sequence...")
    sync_bits = hex_to_bitstream(SYNC_SEQUENCE_HEX, SYNC_SYMBOLS * 2)
    frame_size_bits = FRAME_TOTAL_SYMBOLS * 2
    
    try:
        sync_location = -1
        for i in range(len(demodulated_bitstream) - len(sync_bits)):
            if np.array_equal(demodulated_bitstream[i:i+len(sync_bits)], sync_bits):
                sync_location = i
                break
        if sync_location == -1: raise RuntimeError("Frame sync sequence not found. Decoding failed.")
        print(f"Sync found at bit position {sync_location}.")
        
        aligned_bitstream = demodulated_bitstream[sync_location:]
        num_frames = len(aligned_bitstream) // frame_size_bits
        
        decoded_payload_bits = []
        print("\n--- [RX] RECEIVE FRAME LOG ---")
        for i in range(num_frames):
            start, end = i * frame_size_bits, (i+1) * frame_size_bits
            frame = aligned_bitstream[start:end]
            
            payload_start = (SYNC_SYMBOLS + TARGET_ID_SYMBOLS + COMMAND_TYPE_SYMBOLS) * 2
            payload_end = payload_start + n_codeword_bits
            if len(frame) < payload_end: continue
            noisy_codeword = frame[payload_start:payload_end]
            
            decoded_message = decode(H, noisy_codeword, snr_db)
            
            if i < 3:
                noisy_payload = noisy_codeword[:k_message_bits]
                noisy_ecc = noisy_codeword[k_message_bits:]
                print(f"\n[RX] Frame {i+1}/{num_frames}:")
                print(f"  > Noisy Payload : {bits_to_str(noisy_payload)}...")
                print(f"  > Noisy ECC     : {bits_to_str(noisy_ecc)}")
                print(f"  > Corrected Msg : {bits_to_str(decoded_message)}...")
            
            decoded_payload_bits.extend(decoded_message)
            
        decoded_bitstream = np.array(decoded_payload_bits, dtype=np.uint8)

        print("\n\n--- STAGE 3: VALIDATION REPORT ---")
        trimmed_decoded_stream = decoded_bitstream[:len(original_payload_bits)]
        
        post_fec_errors = np.sum(original_payload_bits != trimmed_decoded_stream)
        post_fec_ber = post_fec_errors / len(original_payload_bits)
        print(f"Found {post_fec_errors} errors after LDPC correction.")
        print(f"Post-FEC Bit Error Rate (BER): {post_fec_ber:.6f}")
        
        recovered_bytes = np.packbits(trimmed_decoded_stream)
        recovered_string = recovered_bytes.tobytes().decode('utf-8', 'ignore').rstrip('\x00')
        
        print("\nOriginal Message:")
        print(f"'{PLAINTEXT_SOURCE}'")
        print("\nRecovered Message:")
        print(f"'{recovered_string}'")

        if recovered_string == PLAINTEXT_SOURCE:
            print("\nVALIDATION: SUCCESS! Original message recovered perfectly.")
        else:
            print("\nVALIDATION: FAILURE! Message could not be recovered.")

    except Exception as e:
        print(f"\nDECODING FAILED: {e}")

# ==============================================================================
# --- HELPER FUNCTIONS AND VISUALIZATION ---
# ==============================================================================

def plot_demodulator_diagnostics(diag_data, ideal_phases, snr_db):
    fig, axs = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Demodulator Diagnostics', fontsize=16)
    
    # 1. Constellation Plot
    ax = axs[0, 0]
    i_samples = diag_data["received_symbols_i"]
    q_samples = diag_data["received_symbols_q"]
    ideal_i, ideal_q = np.cos(ideal_phases), np.sin(ideal_phases)
    ax.scatter(i_samples, q_samples, s=10, alpha=0.3, label="Received Symbols")
    ax.scatter(ideal_i, ideal_q, s=200, c='red', marker='x', linewidth=2, label="Ideal Symbols")
    ax.set_title(f'QPSK Constellation (SNR = {snr_db} dB)')
    ax.set_xlabel('In-Phase (I)'); ax.set_ylabel('Quadrature (Q)')
    ax.grid(True); ax.axhline(0, color='grey', lw=0.5); ax.axvline(0, color='grey', lw=0.5)
    max_val = np.max(np.abs(np.concatenate((i_samples, q_samples)))) * 1.5 if len(i_samples) > 0 else 1.5
    ax.set_xlim([-max_val, max_val]); ax.set_ylim([-max_val, max_val])
    ax.set_aspect('equal', adjustable='box'); ax.legend()

    # Time-domain plots (show first 200 symbols)
    slice_len = min(200, len(diag_data["nco_freq_offset"]))
    t = np.arange(slice_len)

    # 2. NCO Frequency Offset
    ax = axs[0, 1]
    ax.plot(t, diag_data["nco_freq_offset"][:slice_len])
    ax.axhline(FSK_FREQ_DEVIATION_HZ, color='r', linestyle='--', label='FSK "+1 Hz" Offset')
    ax.axhline(-FSK_FREQ_DEVIATION_HZ, color='g', linestyle='--', label='FSK "-1 Hz" Offset')
    ax.set_title('Tracked NCO Frequency Offset (First 200 Symbols)')
    ax.set_xlabel('Symbol Index'); ax.set_ylabel('Frequency Offset (Hz)')
    ax.grid(True); ax.legend()

    # 3. Gardner Timing Error
    ax = axs[1, 0]
    ax.plot(t, diag_data["timing_error"][:slice_len])
    ax.axhline(0, color='red', linestyle='--', alpha=0.7)
    ax.set_title('Gardner Timing Error (First 200 Symbols)')
    ax.set_xlabel('Symbol Index'); ax.set_ylabel('Error Signal')
    ax.grid(True)
    
    # 4. Corrected I/Q
    ax = axs[1, 1]
    ax.plot(t, diag_data["received_symbols_i"][:slice_len], label='I branch', alpha=0.7)
    ax.plot(t, diag_data["received_symbols_q"][:slice_len], label='Q branch', alpha=0.7)
    ax.set_title('Corrected Baseband I/Q Symbols (First 200)')
    ax.set_xlabel('Symbol Index'); ax.set_ylabel('Amplitude')
    ax.grid(True); ax.legend()

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()


def int_to_bitstream(value, num_bits):
    return np.array(list(format(value, f'0{num_bits}b')), dtype=np.uint8)

def hex_to_bitstream(hex_string, expected_bits):
    num_chars = expected_bits // 4
    return np.unpackbits(np.frombuffer(bytes.fromhex(hex_string.zfill(num_chars)), dtype=np.uint8))

def string_to_bitstream(text):
    return np.unpackbits(np.frombuffer(text.encode('utf-8'), dtype=np.uint8))

def bits_to_str(bits, limit=32):
    return "".join(map(str, bits[:limit]))

if __name__ == '__main__':
    try:
        noisy_audio, original_qpsk_stream, original_payload, ideal_phase_map = generate_modulated_audio(SAMPLE_RATE, BIT_DEPTH, SNR_DB)
        demodulate_and_decode(noisy_audio, original_qpsk_stream, original_payload, ideal_phase_map, SNR_DB)
    except Exception as e:
        print(f"\nAn unexpected top-level error occurred: {e}")